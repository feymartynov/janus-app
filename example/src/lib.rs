use std::path::Path;

use janus_app::{Error, Plugin};

use crate::config::Config;

pub struct ExamplePlugin {
    config: Config,
}

impl ExamplePlugin {
    fn new(config: Config) -> Self {
        Self { config }
    }
}

impl Plugin for ExamplePlugin {
    fn version() -> i32 {
        1
    }

    fn description() -> &'static str {
        "Example plugin"
    }

    fn name() -> &'static str {
        "Example"
    }

    fn author() -> &'static str {
        "Anonymous"
    }

    fn package() -> &'static str {
        "example"
    }

    fn is_events_enabled() -> bool {
        false
    }

    fn init(config_path: &Path) -> Result<Box<Self>, Error> {
        let config = Config::from_path(config_path)
            .map_err(|err| Error::new(&format!("Failed to load config: {}", err)))?;

        Ok(Box::new(Self::new(config)))
    }
}

mod config;
mod handle;

///////////////////////////////////////////////////////////////////////////////
// TODO: The code below should be generated by a macro from janus-app crate.
///////////////////////////////////////////////////////////////////////////////

use std::cell::RefCell;
use std::convert::TryInto;
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};

use jansson_sys::{json_dumps, json_loads, json_t};
use janus_app::{
    Handle, HandleCallbacks, HandleRegistry, IncomingMessage, IncomingMessageResponse, MediaEvent,
    MediaKind, MediaProtocol, OutgoingMessage,
};
use janus_plugin_sys::plugin::{
    janus_callbacks as JanusCallbacks, janus_plugin as JanusPlugin,
    janus_plugin_result as JanusPluginResult, janus_plugin_result_type as JanusPluginResultType,
    janus_plugin_session as JanusPluginSession,
};
use serde::{de::DeserializeOwned, ser::Serialize};

use crate::handle::Handle as ExamplePluginHandle;

///////////////////////////////////////////////////////////////////////////////

pub struct App {
    _plugin: ExamplePlugin,
    callbacks: &'static JanusCallbacks,
}

thread_local! {
    static APP: RefCell<Option<App>> = RefCell::new(None);
    static HANDLE_REGISTRY: RefCell<HandleRegistry<'static, ExamplePluginHandle>> =
        RefCell::new(HandleRegistry::new());
}

extern "C" fn init(callbacks: *mut JanusCallbacks, config_path: *const c_char) -> c_int {
    match init_impl(callbacks, config_path) {
        Ok(()) => 0,
        Err(ref err) => {
            janus_log(err);
            1
        }
    }
}

fn init_impl(callbacks: *mut JanusCallbacks, config_path: *const c_char) -> Result<(), String> {
    APP.with(|app| {
        if (*app.borrow()).is_some() {
            return Err(String::from("Plugin already initialized"));
        }

        let config_path = unsafe { CStr::from_ptr(config_path) }
            .to_str()
            .map_err(|err| format!("Failed to cast config path: {}", err))?;

        let plugin = ExamplePlugin::init(&Path::new(config_path))
            .map_err(|err| format!("Failed to init plugin: {}", err))?;

        *app.borrow_mut() = Some(App {
            _plugin: *plugin,
            callbacks: unsafe { &*callbacks },
        });

        Ok(())
    })
}

extern "C" fn destroy() {
    APP.with(|app| {
        if (*app.borrow()).is_some() {
            janus_log("Plugin not initialized");
            return;
        }

        *app.borrow_mut() = None;
        HANDLE_REGISTRY.with(|reg| (*reg.borrow_mut()).clear());
    })
}

extern "C" fn get_api_compatibility() -> c_int {
    13
}

extern "C" fn get_version() -> c_int {
    ExamplePlugin::version()
}

extern "C" fn get_version_string() -> *const c_char {
    CString::new(format!("{}", ExamplePlugin::version()).as_bytes())
        .expect("Failed cast version string")
        .as_ptr()
}

extern "C" fn get_description() -> *const c_char {
    CString::new(ExamplePlugin::description())
        .expect("Failed to cast description")
        .as_ptr()
}

extern "C" fn get_name() -> *const c_char {
    CString::new(ExamplePlugin::name())
        .expect("Failed to cast name")
        .as_ptr()
}

extern "C" fn get_author() -> *const c_char {
    CString::new(ExamplePlugin::author())
        .expect("Failed to cast author")
        .as_ptr()
}

extern "C" fn get_package() -> *const c_char {
    CString::new(ExamplePlugin::package())
        .expect("Failed to cast package")
        .as_ptr()
}

extern "C" fn create_session(handle: *mut JanusPluginSession, error: *mut c_int) {
    let rc = match create_session_impl(handle) {
        Ok(()) => 0,
        Err(ref err) => {
            janus_log(err);
            1
        }
    };

    unsafe { *error = rc };
}

fn create_session_impl(raw_handle: *mut JanusPluginSession) -> Result<(), String> {
    HANDLE_REGISTRY.with(|handle_registry| {
        let reg_mut = &mut *handle_registry.borrow_mut();

        match reg_mut.get_by_raw_handle(raw_handle) {
            Some(_) => Err(String::from("Handle already registered")),
            None => reg_mut
                .add(raw_handle)
                .map(|_| ())
                .map_err(|err| format!("Failed to register handle: {}", err)),
        }
    })
}

extern "C" fn handle_message(
    raw_handle: *mut JanusPluginSession,
    transaction: *mut c_char,
    payload: *mut json_t,
    jsep: *mut json_t,
) -> *mut JanusPluginResult {
    let mut plugin_result = match handle_message_impl(raw_handle, transaction, payload, jsep) {
        Ok(res) => res,
        Err(err) => {
            janus_log(&err);

            let text = CString::new(err).unwrap_or_else(|ref err| {
                janus_log(&format!("Failed to cast error message text: {}", err));
                CString::new("").expect("Failed to cast text")
            });

            JanusPluginResult {
                type_: JanusPluginResultType::JANUS_PLUGIN_ERROR,
                text: text.into_raw(),
                content: std::ptr::null_mut(),
            }
        }
    };

    &mut plugin_result
}

fn handle_message_impl(
    raw_handle: *mut JanusPluginSession,
    transaction: *mut c_char,
    payload: *mut json_t,
    jsep: *mut json_t,
) -> Result<JanusPluginResult, String> {
    HANDLE_REGISTRY.with(|handle_registry| {
        let reg_ref = &*handle_registry.borrow();

        let (_, plugin_handle) = reg_ref
            .get_by_raw_handle(raw_handle)
            .ok_or_else(|| String::from("Handle not found"))?;

        let transaction_str = unsafe { CString::from_raw(transaction) }
            .to_str()
            .map(|s| String::from(s))
            .map_err(|err| format!("Failed to cast transaction: {}", err))?;

        let message =
            IncomingMessage::new(transaction_str, deserialize(payload)?, deserialize(jsep)?);

        match plugin_handle.handle_message(&message) {
            Err(err) => Err(format!("Error handlung message: {}", err)),
            Ok(IncomingMessageResponse::Ack) => Ok(JanusPluginResult {
                type_: JanusPluginResultType::JANUS_PLUGIN_OK_WAIT,
                text: CString::new("").expect("Failed to cast text").into_raw(),
                content: std::ptr::null_mut(),
            }),
            Ok(IncomingMessageResponse::Syncronous(response_payload)) => {
                // TODO: Pass custom type instead of `serde_json::Value`.
                serialize::<serde_json::Value>(response_payload)
                    .map(|content| JanusPluginResult {
                        type_: JanusPluginResultType::JANUS_PLUGIN_OK,
                        text: CString::new("").expect("Failed to cast text").into_raw(),
                        content,
                    })
                    .map_err(|err| format!("Failed to serialize response payload: {}", err))
            }
        }
    })
}

extern "C" fn setup_media(raw_handle: *mut JanusPluginSession) {
    if let Err(ref err) = dispatch_media_event(raw_handle, &MediaEvent::Setup) {
        janus_log(err);
    }
}

extern "C" fn incoming_rtp(
    raw_handle: *mut JanusPluginSession,
    is_video: c_int,
    buffer: *mut c_char,
    len: c_int,
) {
    let media_event = MediaEvent::Media {
        protocol: MediaProtocol::Rtp,
        kind: media_kind(is_video),
        buffer: unsafe { std::slice::from_raw_parts(buffer as *const i8, len as usize) },
    };

    if let Err(ref err) = dispatch_media_event(raw_handle, &media_event) {
        janus_log(err);
    }
}

extern "C" fn incoming_rtcp(
    raw_handle: *mut JanusPluginSession,
    is_video: c_int,
    buffer: *mut c_char,
    len: c_int,
) {
    let media_event = MediaEvent::Media {
        protocol: MediaProtocol::Rtcp,
        kind: media_kind(is_video),
        buffer: unsafe { std::slice::from_raw_parts(buffer as *const i8, len as usize) },
    };

    if let Err(ref err) = dispatch_media_event(raw_handle, &media_event) {
        janus_log(err);
    }
}

extern "C" fn incoming_data(raw_handle: *mut JanusPluginSession, buffer: *mut c_char, len: c_int) {
    let media_event = MediaEvent::Data {
        buffer: unsafe { std::slice::from_raw_parts(buffer as *const i8, len as usize) },
    };

    if let Err(ref err) = dispatch_media_event(raw_handle, &media_event) {
        janus_log(err);
    }
}

extern "C" fn slow_link(raw_handle: *mut JanusPluginSession, uplink: c_int, is_video: c_int) {
    if let Err(ref err) = slow_link_impl(raw_handle, uplink, is_video) {
        janus_log(err);
    }
}

fn slow_link_impl(
    raw_handle: *mut JanusPluginSession,
    uplink: c_int,
    is_video: c_int,
) -> Result<(), String> {
    let uplink = uplink
        .try_into()
        .map_err(|err| format!("Failed to cast uplink: {}", err))?;

    let media_event = MediaEvent::SlowLink {
        kind: media_kind(is_video),
        uplink,
    };

    dispatch_media_event(raw_handle, &media_event)
}

extern "C" fn hangup_media(raw_handle: *mut JanusPluginSession) {
    if let Err(ref err) = dispatch_media_event(raw_handle, &MediaEvent::Hangup) {
        janus_log(err);
    }
}

extern "C" fn destroy_session(raw_handle: *mut JanusPluginSession, error: *mut c_int) {
    HANDLE_REGISTRY.with(|handle_registry| {
        let rc = match (*handle_registry.borrow_mut()).remove(raw_handle) {
            Ok(()) => 0,
            Err(ref err) => {
                janus_log(&format!("Failed to destroy session: {}", err));
                1
            }
        };

        unsafe { *error = rc };
    })
}

extern "C" fn query_session(raw_handle: *mut JanusPluginSession) -> *mut json_t {
    match query_session_impl(raw_handle) {
        Ok(json) => json,
        Err(ref err) => {
            janus_log(err);
            std::ptr::null_mut()
        }
    }
}

fn query_session_impl(raw_handle: *mut JanusPluginSession) -> Result<*mut json_t, String> {
    HANDLE_REGISTRY.with(|handle_registry| {
        let reg_ref = &*handle_registry.borrow();

        let (_, plugin_handle) = reg_ref
            .get_by_raw_handle(raw_handle)
            .ok_or_else(|| String::from("Handle not found"))?;

        serialize(plugin_handle)
    })
}

const JANUS_PLUGIN: JanusPlugin = JanusPlugin {
    init,
    destroy,
    get_api_compatibility,
    get_version,
    get_version_string,
    get_description,
    get_name,
    get_author,
    get_package,
    create_session,
    handle_message,
    setup_media,
    incoming_rtp,
    incoming_rtcp,
    incoming_data,
    slow_link,
    hangup_media,
    destroy_session,
    query_session,
};

#[no_mangle]
pub extern "C" fn create() -> *const JanusPlugin {
    &JANUS_PLUGIN
}

///////////////////////////////////////////////////////////////////////////////

impl HandleCallbacks for ExamplePluginHandle {
    fn log(&self, message: &str) {
        janus_log(message);
    }

    fn relay_media_packet(&self, protocol: MediaProtocol, kind: MediaKind, buffer: &mut [i8]) {
        if let Err(ref err) = handle_callback_relay_media_packet(self, protocol, kind, buffer) {
            janus_log(err);
        }
    }

    fn relay_data_packet(&self, buffer: &mut [i8]) {
        if let Err(ref err) = handle_callback_relay_data_packet(self, buffer) {
            janus_log(err);
        }
    }

    fn close_peer_connection(&self) {
        if let Err(ref err) = handle_callback_close_peer_connection_impl(self) {
            janus_log(err);
        }
    }

    fn end(&self) {
        if let Err(ref err) = handle_callback_end_impl(self) {
            janus_log(err);
        }
    }

    fn notify_event<E: Serialize>(&self, event: &E) {
        if let Err(ref err) = handle_callback_notify_event_impl(self, event) {
            janus_log(err);
        }
    }

    fn push_event<P: Serialize, J: Serialize>(
        &self,
        message: OutgoingMessage<P, J>,
    ) -> Result<(), Error> {
        APP.with(|app| {
            HANDLE_REGISTRY.with(|handle_registry| {
                let reg_ref = &mut *handle_registry.borrow_mut();

                let (ref mut raw_handle, _) = reg_ref
                    .get_by_id_mut(self.id())
                    .ok_or_else(|| Error::new(&format!("Handle {} not found", self.id())))?;

                let txn = CString::new(message.transaction().to_owned())
                    .map_err(|err| Error::new(&format!("Failed to cast transaction: {}", err)))?;

                let payload = serialize(message.payload())
                    .map_err(|err| Error::new(&format!("Failed to serialize payload: {}", err)))?;

                let jsep = serialize(message.jsep())
                    .map_err(|err| Error::new(&format!("Failed to serialize JSEP: {}", err)))?;

                let callback = (*app.borrow())
                    .as_ref()
                    .ok_or_else(|| Error::new("Plugin not initialized"))?
                    .callbacks
                    .push_event;

                let rc = callback(
                    *raw_handle,
                    &mut JANUS_PLUGIN,
                    txn.into_raw(),
                    payload,
                    jsep,
                );

                match rc {
                    0 => Ok(()),
                    _ => Err(Error::new("Failed to push event")),
                }
            })
        })
    }
}

fn handle_callback_relay_media_packet(
    handle: &ExamplePluginHandle,
    protocol: MediaProtocol,
    kind: MediaKind,
    buffer: &mut [i8],
) -> Result<(), String> {
    APP.with(|app| {
        HANDLE_REGISTRY.with(|handle_registry| {
            let reg_ref = &mut *handle_registry.borrow_mut();

            let (ref mut raw_handle, _) = reg_ref
                .get_by_id_mut(handle.id())
                .ok_or_else(|| format!("Handle {} not found", handle.id()))?;

            let callbacks = (*app.borrow())
                .as_ref()
                .ok_or_else(|| String::from("Plugin not initialized"))?
                .callbacks;

            let callback = match protocol {
                MediaProtocol::Rtp => callbacks.relay_rtp,
                MediaProtocol::Rtcp => callbacks.relay_rtcp,
            };

            let is_video = match kind {
                MediaKind::Video => 1,
                MediaKind::Audio => 0,
            };

            callback(
                *raw_handle,
                is_video,
                buffer.as_mut_ptr(),
                buffer.len() as i32,
            );

            Ok(())
        })
    })
}

fn handle_callback_relay_data_packet(
    handle: &ExamplePluginHandle,
    buffer: &mut [i8],
) -> Result<(), String> {
    APP.with(|app| {
        HANDLE_REGISTRY.with(|handle_registry| {
            let reg_ref = &mut *handle_registry.borrow_mut();

            let (ref mut raw_handle, _) = reg_ref
                .get_by_id_mut(handle.id())
                .ok_or_else(|| format!("Handle {} not found", handle.id()))?;

            let callbacks = (*app.borrow())
                .as_ref()
                .ok_or_else(|| String::from("Plugin not initialized"))?
                .callbacks;

            (callbacks.relay_data)(*raw_handle, buffer.as_mut_ptr(), buffer.len() as i32);
            Ok(())
        })
    })
}

fn handle_callback_close_peer_connection_impl(handle: &ExamplePluginHandle) -> Result<(), String> {
    APP.with(|app| {
        HANDLE_REGISTRY.with(|handle_registry| {
            let reg_ref = &mut *handle_registry.borrow_mut();

            let (ref mut raw_handle, _) = reg_ref
                .get_by_id_mut(handle.id())
                .ok_or_else(|| format!("Handle {} not found", handle.id()))?;

            let callbacks = (*app.borrow())
                .as_ref()
                .ok_or_else(|| String::from("Plugin not initialized"))?
                .callbacks;

            (callbacks.close_pc)(*raw_handle);
            Ok(())
        })
    })
}

fn handle_callback_end_impl(handle: &ExamplePluginHandle) -> Result<(), String> {
    APP.with(|app| {
        HANDLE_REGISTRY.with(|handle_registry| {
            let reg_ref = &mut *handle_registry.borrow_mut();

            let (ref mut raw_handle, _) = reg_ref
                .get_by_id_mut(handle.id())
                .ok_or_else(|| format!("Handle {} not found", handle.id()))?;

            let callbacks = (*app.borrow())
                .as_ref()
                .ok_or_else(|| String::from("Plugin not initialized"))?
                .callbacks;

            (callbacks.end_session)(*raw_handle);
            Ok(())
        })
    })
}

fn handle_callback_notify_event_impl<E: Serialize>(
    handle: &ExamplePluginHandle,
    event: &E,
) -> Result<(), String> {
    APP.with(|app| {
        HANDLE_REGISTRY.with(|handle_registry| {
            let reg_ref = &mut *handle_registry.borrow_mut();

            let (ref mut raw_handle, _) = reg_ref
                .get_by_id_mut(handle.id())
                .ok_or_else(|| format!("Handle {} not found", handle.id()))?;

            let callbacks = (*app.borrow())
                .as_ref()
                .ok_or_else(|| String::from("Plugin not initialized"))?
                .callbacks;

            let event_json =
                serialize(event).map_err(|err| format!("Failed to serialize: {}", err))?;

            (callbacks.notify_event)(&mut JANUS_PLUGIN, *raw_handle, event_json);
            Ok(())
        })
    })
}

///////////////////////////////////////////////////////////////////////////////

fn janus_log(message: &str) {
    // TODO: Add better logging with levels and colors.
    let c_message = CString::new(message).expect("Failed to cast error message");
    unsafe { janus_plugin_sys::janus_vprintf(c_message.as_ptr()) };
}

fn media_kind(is_video: c_int) -> MediaKind {
    match is_video {
        0 => MediaKind::Audio,
        _ => MediaKind::Video,
    }
}

fn dispatch_media_event(
    raw_handle: *mut JanusPluginSession,
    media_event: &MediaEvent,
) -> Result<(), String> {
    HANDLE_REGISTRY.with(|handle_registry| {
        match (*handle_registry.borrow()).get_by_raw_handle(raw_handle) {
            None => Err(String::from("Handle not found")),
            Some((_, plugin_handle)) => {
                plugin_handle.handle_media_event(media_event);
                Ok(())
            }
        }
    })
}

fn serialize<S: Serialize>(object: &S) -> Result<*mut json_t, String> {
    // TODO: Dump JSON to string with serde and load back with jansson is suboptimal.
    //       It would be better to implement serde_jansson.
    let dump = serde_json::ser::to_string(object)
        .map_err(|err| format!("Failed to dump JSON: {}", err))?;

    let dump_cstring = CString::new(dump.as_str())
        .map_err(|err| format!("Failed to cast dumped JSON: {}", err))?;

    let ptr = unsafe { json_loads((&dump_cstring).as_ptr(), 0, std::ptr::null_mut()).as_mut() };

    ptr.map(|p| p as *mut json_t)
        .ok_or_else(|| String::from("Failed to load dumped JSON"))
}

fn deserialize<D: DeserializeOwned>(json: *mut json_t) -> Result<D, String> {
    // TODO: Dump JSON to string with jansson and load back with serde is suboptimal.
    //       It would be better to implement serde_jansson.
    let dump_cstring = match unsafe { json_dumps(json, 0).as_mut() } {
        Some(ptr) => unsafe { CString::from_raw(ptr) },
        None => return Err(String::from("Failed to dump JSON")),
    };

    let dump_str = dump_cstring
        .to_str()
        .map_err(|err| format!("Failed to cast dumped JSON: {}", err))?;

    serde_json::from_str::<D>(dump_str)
        .map_err(|err| format!("Failed to deserialize JSON: {}", err))
}
